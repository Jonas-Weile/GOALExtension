/**
 * Knowledge Representation Tools. Copyright (C) 2014 Koen Hindriks.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

package cognitiveKr;

import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import krTools.KRInterface;
import krTools.exceptions.ParserException;
import krTools.language.DatabaseFormula;
import krTools.language.Expression;
import krTools.language.Query;
import krTools.language.Term;
import krTools.language.Update;
import krTools.language.Var;
import krTools.parser.Parser;
import krTools.parser.SourceInfo;

/**
 * A number of functions in this class are returning signatures. A signature is
 * a string that contains meta-information about predicates. If a predicate
 * p(a1...aN) is a predicate in the language, then the signature is "p/N" where
 * N the number of arguments of p. So the signature is a String containing a
 * tuple with the name and arity of the predicate, separated by a slash.
 *
 */
public abstract class CognitiveKR {
	protected final KRInterface kri;
	private List<SourceInfo> errors = new LinkedList<>();

	protected CognitiveKR(final KRInterface kri) {
		this.kri = kri;
	}

	protected abstract SourceInfo getSourceInfo(File source) throws IOException;

	/**
	 * @return A list of errors that were possibly generated by the previous
	 *         (single) call to a public method in this class.
	 */
	public List<SourceInfo> getErrors() {
		return this.errors;
	}

	/**
	 * Processes an external KR language fragment (file), assuming that it is used
	 * for a knowledge. Specific KR languages might pose additional restrictions on
	 * the more generic list of DatabaseFormulas that is returned, through the
	 * {@link ParserException} or {@link #getErrors()}.
	 *
	 * @param source File with KR fragment.
	 * @return List of {@link DatabaseFormula}s.
	 * @throws ParserException See {@link ParserException}.
	 */
	public List<DatabaseFormula> visitKnowledgeFile(final File source) throws ParserException {
		return visit_KR_Formulas(source);
	}

	/**
	 * Processes an external KR language fragment (file), assuming that it is used
	 * for a beliefs. Specific KR languages might pose additional restrictions on
	 * the more generic list of DatabaseFormulas that is returned, through the
	 * {@link ParserException} or {@link #getErrors()}.
	 *
	 * @param source File with KR fragment.
	 * @return List of {@link DatabaseFormula}s.
	 * @throws ParserException See {@link ParserException}.
	 */
	public List<DatabaseFormula> visitBeliefFile(final File source) throws ParserException {
		return visit_KR_Formulas(source);
	}

	/**
	 * Processes an external KR language fragment (file), assuming that it is used
	 * for a goals. Specific KR languages might pose additional restrictions on the
	 * more generic list of Queries that is returned, through the
	 * {@link ParserException} or {@link #getErrors()}.
	 *
	 * @param source File with KR fragment.
	 * @return List of {@link Query}s.
	 * @throws ParserException See {@link ParserException}.
	 */
	public List<Query> visitGoalFile(final File source) throws ParserException {
		return visit_KR_Queries(source);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used for a
	 * belief insertion. Specific KR languages might pose additional restrictions on
	 * the more generic Update that is returned, through the {@link ParserException}
	 * or {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Update}.
	 * @throws ParserException See {@link ParserException}.
	 */
	public Update visitBeliefInsert(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Update(krFragment, info);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used for a
	 * belief deletion. Specific KR languages might pose additional restrictions on
	 * the more generic Update that is returned, through the {@link ParserException}
	 * or {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Update}.
	 * @throws ParserException See {@link ParserException}.
	 */
	public Update visitBeliefDelete(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Update(krFragment, info);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used for a
	 * goal adoption. Specific KR languages might pose additional restrictions on
	 * the more generic Update that is returned, through the {@link ParserException}
	 * or {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Update}.
	 * @throws ParserException See {@link ParserException}.
	 */
	public Update visitGoalAdopt(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Update(krFragment, info);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used for a
	 * goal drop. Specific KR languages might pose additional restrictions on the
	 * more generic Update that is returned, through the {@link ParserException} or
	 * {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Update}.
	 * @throws ParserException See {@link ParserException}.
	 */
	public Update visitGoalDrop(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Update(krFragment, info);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used for a
	 * send action (message content). Specific KR languages might pose additional
	 * restrictions on the more generic Update that is returned, through the
	 * {@link ParserException} or {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Update}.
	 * @throws ParserException See {@link ParserException}.
	 */
	public Update visitSend(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Update(krFragment, info);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used for
	 * querying beliefs. Specific KR languages might pose additional restrictions on
	 * the more generic Query that is returned, through the {@link ParserException}
	 * or {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Query}.
	 * @throws ParserException See {@link ParserException}.
	 */
	public Query visitBeliefQuery(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Query(krFragment, info);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used for
	 * querying goals. Specific KR languages might pose additional restrictions on
	 * the more generic Query that is returned, through the {@link ParserException}
	 * or {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Query}.
	 * @throws ParserException See {@link ParserException}.
	 */
	public Query visitGoalQuery(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Query(krFragment, info);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used for
	 * querying message(contents). Specific KR languages might pose additional
	 * restrictions on the more generic Query that is returned, through the
	 * {@link ParserException} or {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Query}.
	 * @throws ParserException See {@link ParserException}.
	 */
	public Query visitSent(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Query(krFragment, info);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used for
	 * querying percepts. Specific KR languages might pose additional restrictions
	 * on the more generic Query that is returned, through the
	 * {@link ParserException} or {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Query}.
	 * @throws ParserException See {@link ParserException}.
	 */
	public Query visitPercept(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Query(krFragment, info);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used as a
	 * listall variable. Specific KR languages might pose additional restrictions on
	 * the more generic Var that is returned, through the {@link ParserException} or
	 * {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Var}.
	 * @throws ParserException See {@link ParserException}.
	 */
	public Var visitListallVar(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Var(krFragment, info);
	}

	/**
	 * Processes an embedded KR language fragment, assuming that it is used as a
	 * list of arguments (e.g. for an action or module call). Specific KR languages
	 * might pose additional restrictions on the more generic list of Terms that is
	 * returned, through the {@link ParserException} or {@link #getErrors()}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return List of {@link Term}s.
	 * @throws ParserException See {@link ParserException}.
	 */
	public List<Term> visitArguments(final String krFragment, final SourceInfo info) throws ParserException {
		return visit_KR_Terms(krFragment, info);
	}

	/**
	 * Processes embedded KR language fragments (used for built-in actions). Assumes
	 * that these fragments represent an {@link Update}.
	 *
	 * @param krFragment String with KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return {@link Update}.
	 * @throws ParserException See {@link ParserException}.
	 */
	private Update visit_KR_Update(final String krFragment, final SourceInfo info) throws ParserException {
		// Get the parser
		final Parser parser = this.kri.getParser(new StringReader(krFragment), info);
		// Get the update
		final Update update = parser.parseUpdate();
		// Add errors from parser for embedded language to our own.
		this.errors = parser.getErrors();
		// Return the result
		return update;
	}

	/**
	 * Processes embedded KR language fragments (used for mental literals and
	 * preconditions). Assumes that these fragments represent a {@link Query}.
	 *
	 * @param krFragment A KR fragment.
	 * @param info       the source info where in the source is this text fragment
	 * @return A {@link Query}.
	 * @throws ParserException See {@link ParserException}.
	 */
	private Query visit_KR_Query(final String krFragment, final SourceInfo info) throws ParserException {
		// Get the parser
		final Parser parser = this.kri.getParser(new StringReader(krFragment), info);
		// Get the query
		final Query query = parser.parseQuery();
		// Add errors from parser for embedded language to our own
		this.errors = parser.getErrors();
		// Return the result
		return query;
	}

	/**
	 * Processes embedded KR language fragment (used for all parameter lists of
	 * actions, macros, modules, and also for content of mental literals and mental
	 * actions). Assumes that these fragments represent a {@link Term}.
	 *
	 * @param krFragment KR fragment string.
	 * @param info       the source info where in the source is this text fragment
	 * @return A {@link Term}.
	 * @throws ParserException See {@link ParserException}.
	 */
	private List<Term> visit_KR_Terms(final String krFragment, final SourceInfo info) throws ParserException {
		// Get the parser
		final Parser parser = this.kri.getParser(new StringReader(krFragment), info);
		// Get the terms.
		final List<Term> parameters = parser.parseTerms();
		// Add errors from parser for embedded language to our own
		this.errors = parser.getErrors();
		// Return the (non-null) result
		if (parameters == null) {
			return new ArrayList<>(0);
		} else {
			return parameters;
		}
	}

	/**
	 * Parses a terminal node that should contain the text (name) of a variable. In
	 * other words, assumes that the text associated with the node represents a
	 * {@link Var}.
	 *
	 * @param name the variable text to be parsed.
	 * @param info the source info where in the source is this text fragment
	 * @return The variable we got from parsing the node.
	 * @throws ParserException See {@link ParserException}.
	 */
	private Var visit_KR_Var(final String name, final SourceInfo info) throws ParserException {
		// Get the parser
		final Parser parser = this.kri.getParser(new StringReader(name), info);
		// Get the variable
		final Var var = parser.parseVar();
		// Add errors from parser for embedded language to our own
		this.errors = parser.getErrors();
		// Return the result
		return var;
	}

	/**
	 * Processes external KR language fragment (file). Assumes that these fragments
	 * represent a List of {@link DatabaseFormula}s.
	 *
	 * @param source KR fragment source.
	 * @return A List of {@link DatabaseFormula}s.
	 * @throws ParserException See {@link ParserException}.
	 */
	private List<DatabaseFormula> visit_KR_Formulas(final File source) throws ParserException {
		try {
			// Get the parser
			final Parser parser = this.kri.getParser(getReader(source), getSourceInfo(source));
			// Get the formulas.
			final List<DatabaseFormula> dbfs = parser.parseDBFs();
			// Add errors from parser for embedded language to our own
			this.errors = parser.getErrors();
			// Return the (non-null) result
			if (dbfs == null) {
				return new ArrayList<>(0);
			} else {
				return dbfs;
			}
		} catch (final IOException e) {
			throw new ParserException(e.getMessage(), source);
		}
	}

	/**
	 * Processes external KR language fragment (file). Assumes that these fragments
	 * represent a List of {@link Query}s.
	 *
	 * @param source KR fragment source.
	 * @return A List of {@link Query}s.
	 * @throws ParserException See {@link ParserException}.
	 */
	private List<Query> visit_KR_Queries(final File source) throws ParserException {
		try {
			// Get the parser
			final Parser parser = this.kri.getParser(getReader(source), getSourceInfo(source));
			// Get the queries.
			final List<Query> queries = parser.parseQueries();
			// Add errors from parser for embedded language to our own
			this.errors = parser.getErrors();
			// Return the (non-null) result
			if (queries == null) {
				return new ArrayList<>(0);
			} else {
				return queries;
			}
		} catch (final IOException e) {
			throw new ParserException(e.getMessage(), source);
		}
	}

	/**
	 * Extract the defined signature(s) from the {@link DatabaseFormula}. A
	 * signature is defined if the databaseformula defines a predicate of that
	 * signature (as fact or as following from inference.
	 * <p>
	 * For example, <code>p/1</code> is defined signature in formulas like
	 * <code>p(1)</code> or <code>p(X):-q(X)</code>)
	 *
	 * (TODO explain the prolog "signature" term in general)
	 *
	 * @param expression the {@link DatabaseFormula} to extract the defined
	 *                   signatures from.
	 * @return signature(s) that are defined by the expression
	 */
	abstract public Set<String> getDefinedSignatures(DatabaseFormula formula) throws ParserException;

	/**
	 * Extract the explicitly declared but undefined signature(s) from the
	 * {@link DatabaseFormula}. In some languages a database formula can declare a
	 * signature exists without giving a definition for it.
	 * <p>
	 * For example, <code>q/1</code> is explicitly declared in
	 * <code>:-dynamic q/1</code>. However, the code <code>p(X):-q(X)</code> does
	 * not <em>explicitly</em> declare q/1.
	 *
	 * @param expression the {@link DatabaseFormula} to extract the defined
	 *                   signatures from.
	 * @return explicitly declared but undefined signatures in the formula.
	 */
	abstract public Set<String> getDeclaredSignatures(DatabaseFormula formula) throws ParserException;

	/**
	 * @param expression
	 * @throws ParserException
	 * @return All occurrences of all (non-anonymous) variables in the given
	 *         expression
	 */
	abstract public List<Var> getAllVariables(Expression expression) throws ParserException;

	/**
	 * Extract the non-system defined signature(s) from the {@link Expression}.
	 * Extracting means that also the inside of expressions are scanned, for example
	 * if the term is not(p(q(X))) , the term p/1 and q/1 should be also extracted.
	 * <p>
	 *
	 * @param expression the {@link DatabaseFormula} to extract the defined
	 *                   signatures from.
	 * @return signature(s) that are used in the expression
	 */
	abstract public Set<String> getUsedSignatures(Expression expression);

	private static Reader getReader(final File source) throws IOException {
		return Files.newBufferedReader(source.toPath());
	}

}
