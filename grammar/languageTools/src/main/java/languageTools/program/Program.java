/**
 * The GOAL Grammar Tools. Copyright (C) 2014 Koen Hindriks.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

package languageTools.program;

import java.io.File;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import krFactory.KRFactory;
import krTools.KRInterface;
import krTools.exceptions.KRInitFailedException;
import krTools.exceptions.KRInterfaceNotSupportedException;
import krTools.language.DatabaseFormula;
import krTools.language.Query;
import krTools.parser.ParsedObject;
import krTools.parser.SourceInfo;
import languageTools.analyzer.FileRegistry;
import languageTools.program.actionspec.ActionSpecProgram;
import languageTools.program.actionspec.UserSpecAction;
import languageTools.program.agent.Module;
import languageTools.program.kr.KRProgram;
import languageTools.program.mas.UseClause;
import languageTools.program.mas.UseClause.UseCase;
import languageTools.program.planner.PlanningModule;
import languageTools.utils.Extension;

/**
 * Generic interface for all types of programs, i.e., MAS programs, agent
 * programs, modules, and tests, that may be generated by the GOAL Grammar
 * Tools.
 */
public abstract class Program extends GoalParsedObject {
	/**
	 * Use clauses of this program.
	 */
	private Set<UseClause> useClauses = new LinkedHashSet<>();
	/**
	 * KR Interface used in program.
	 */
	private KRInterface kri = null;
	/**
	 * The file registry.
	 */
	protected final FileRegistry registry;
	/**
	 * A mapping of SourceInfo > ParsedObject
	 */
	private final ProgramMap map = new ProgramMap();

	/**
	 * Creates a new empty program.
	 *
	 * @param info Source info.
	 */
	public Program(FileRegistry registry, SourceInfo info) {
		super(info);
		this.registry = registry;
	}

	public FileRegistry getRegistry() {
		return this.registry;
	}

	public ProgramMap getMap() {
		return this.map;
	}

	protected void register(ParsedObject object) {
		this.map.register(object);
	}

	/**
	 * @param useClause A use clause specified of the program.
	 *
	 * @return {@code true} if the clause was successfully added; {@code false}
	 *         otherwise.
	 */
	public boolean addUseClause(UseClause useClause) {
		return getSourceFile().equals(useClause.getResolvedReference()) ? false : this.useClauses.add(useClause);
	}

	/**
	 * @return The use clauses of this program (excluding useclauses of the referred
	 *         files).
	 */
	public Set<UseClause> getUseClauses() {
		return Collections.unmodifiableSet(this.useClauses);
	}

	/**
	 * @return All use clauses of this program that have an action spec use case.
	 */
	public List<UseClause> getASUseClauses() {
		List<UseClause> asUseClauses = new LinkedList<>();
		for (UseClause useClause : this.useClauses) {
			if (useClause.getUseCase() == UseCase.ACTIONSPEC) {
				asUseClauses.add(useClause);
			}
		}
		return asUseClauses;
	}

	/**
	 * @return All use clauses of this program that have a KR use case.
	 */
	public List<UseClause> getKRUseClauses() {
		List<UseClause> krUseClauses = new LinkedList<>();
		for (UseClause useClause : this.useClauses) {
			if (useClause.hasKRUseCase()) {
				krUseClauses.add(useClause);
			}
		}
		return krUseClauses;
	}

	/**
	 * Collects all items associated with a particular use case of referenced files.
	 * E.g. collects all database formulas from referenced files that are used for
	 * specifying the agent's knowledge, and all action specifications from
	 * referenced action specification files.
	 *
	 * @param useCase A use case. Should be either {@link UseCase#KNOWLEDGE},
	 *                {@link UseCase#BELIEFS}, {@link UseCase#GOALS}, or
	 *                {@link UseCase#ACTIONSPEC}.
	 * @return List with items associated with use case. Empty list if there are no
	 *         items of the type requested.
	 */
	public List<?> getItems(UseCase useCase) {
		List<DatabaseFormula> dbfItems = new LinkedList<>();
		List<Query> qryItems = new LinkedList<>();
		List<UserSpecAction> asItems = new LinkedList<>();
		List<Module> moduleItems = new LinkedList<>();
		List<PlanningModule> planningModuleItems = new LinkedList<>();
		for (UseClause useClause : getUseClauses()) {
			for (File source : useClause.getResolvedReference()) {
				if (useCase.equals(useClause.getUseCase())) {
					Program program = this.registry.getProgram(source);
					if (program == null) {
						throw new IllegalArgumentException("cannot get program for '" + source + "'.");
					}
					switch (useCase) {
					case KNOWLEDGE:
					case BELIEFS:
						dbfItems.addAll(((KRProgram) program).getDBFormulas());
						break;
					case GOALS:
						qryItems.addAll(((KRProgram) program).getQueries());
						break;
					case ACTIONSPEC:
						asItems.addAll(((ActionSpecProgram) program).getActionSpecifications());
						break;
					case MODULE:
						moduleItems.add((Module) program);
						break;
					case PLANNER:
						planningModuleItems.add((PlanningModule) program);
						break;
					default:
						throw new IllegalArgumentException("cannot get items for use case '" + useCase + "'.");
					}
				}
			}
		}

		switch (useCase) {
		case KNOWLEDGE:
		case BELIEFS:
			return dbfItems;
		case GOALS:
			return qryItems;
		case ACTIONSPEC:
			return asItems;
		case MODULE:
			return moduleItems;
		case PLANNER:
			return planningModuleItems;
		default:
			throw new IllegalArgumentException("Cannot get items for use case '" + useCase + "'.");
		}
	}

	/**
	 * @return The KR files referenced in use clauses.
	 */
	public Set<File> getReferencedKRFiles() {
		Set<File> files = new LinkedHashSet<>();
		for (UseClause useClause : getKRUseClauses()) {
			files.addAll(useClause.getResolvedReference());
		}
		return files;
	}

	/**
	 * The set of KRInterface instances that we have already initialized. This
	 * allows for the re-use of a specific KRInterface class. FIXME: this is quite
	 * hacky...
	 */
	private final static Map<String, KRInterface> had = new ConcurrentHashMap<>();

	/**
	 * Tries to infer from the given use clauses for KR files, and if successful
	 * sets, the KR interface used in this program.
	 *
	 * @return {@code true} if KR interface could successfully be inferred,
	 *         {@code false} otherwise.
	 */
	public boolean resolveKRInterface() {
		Set<File> KRfiles = getReferencedKRFiles();
		Set<String> KRInames = new LinkedHashSet<>(KRfiles.size());
		for (File file : KRfiles) {
			KRInames.add(Extension.getFileExtension(file).getType());
		}

		// Set KR interface.
		if (KRInames.size() == 1) {
			String name = null;
			try {
				name = KRInames.iterator().next();
				this.kri = had.get(name);
				if (this.kri == null) {
					this.kri = KRFactory.getKR(name);
				}
				if (this.kri != null) {
					had.put(name, this.kri);
					return true;
				} else {
					return false;
				}
			} catch (KRInterfaceNotSupportedException e) {
				throw new IllegalArgumentException("unknown KR interface '" + name + "'.");
			} catch (KRInitFailedException e) { // FIXME
				throw new RuntimeException("KR interface '" + name + "' failed to initialize.", e);
			}
		} else {
			return false;
		}
	}

	/**
	 * @return The KR interface used in the program. If a KR interface has not been
	 *         set, this function will try to resolve it, but may eventually still
	 *         return {@code null} if that is not possible.
	 */
	public KRInterface getKRInterface() {
		if (this.kri == null) {
			resolveKRInterface();
		}
		return this.kri;
	}

	/**
	 * Sets the KR interface used in this program.
	 *
	 * @param kri A KR interface.
	 */
	public void setKRInterface(KRInterface kri) {
		this.kri = kri;
	}

	/**
	 * @return The source file used to construct this program.
	 */
	public File getSourceFile() {
		return new File(this.info.getSource());
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = getClass().hashCode();
		result = prime * result + ((this.info == null) ? 0 : this.info.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		} else if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		Program other = (Program) obj;
		if (this.info == null) {
			if (other.info != null) {
				return false;
			}
		} else if (!this.info.equals(other.info)) {
			return false;
		}
		return true;
	}
}
